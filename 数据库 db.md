# MySQL

## 为什么使用 B+树

hash 存储索引，平均时间O(1)；B+ 树 平均查询时间和树的高度有关， log(n)。

**hash**：只有精确所有列生成的hash的查询才有效；不是按照索引值顺序排序的，所以无法用于排序，即无法根据区间快速查找；只支持等值查询，不支持范围查找。

**二叉查找树**：左子树的值均小于根节点的值，右子树的值均大于根节点的值，且任意节点的左右字树也分别是二叉查找树。缺点是在一些极端情况下，比如插入的序列是有序的，就会出现退化的情况，退化成链表。

**平衡二叉树 AVL**：通过旋转来保持平衡，但是旋转非常耗时，效率低；

**红黑树**：一种二叉查找树，但是在每个节点增加一个存储位表示节点的颜色，可以是红或者黑。是一种弱平衡二叉树。相比于平衡二叉树，他的旋转次数变少。Java 中 TreeMap 使用的 红黑树。

**B-树**：B 树是一种多路搜索树，每个节点可以拥有多余两个孩子节点。M路的B树最多能拥有M个孩子节点

（树的查找性能取决于树的高度，让树尽可能保持平衡，就是为了降低树的高度）

在计算机里，无论是内存还是磁盘，操作系统都是按页的大小进行读取的（页的 大小通常为4kb），磁盘每次读取都会预读，会提前将连续的数据读入内存中，这样就避免了多次IO，这就是计算机中的局部性原理。这个连续数据必须是操作系统页大小的整数倍。 Mysql 使用页存储，默认值为 16KB，也就是说对于 B+树的节点，最好设置成页的大小，这样一个 B+树上的节点就只有有一次 IO读。

**B+树**：B+树非叶子节点不存储数据，只存储索引，只有叶子节点存储数据（避免跨层访问），并且叶子节点通过链表串在一起，这样可以方便按区间查找。

​       优点：

- 相比于二叉树，是一种多路搜索树，降低了树的高度，提高树的查找效率
- 相比于其他非树结构，方便分批将磁盘中数据加载到内存，按照磁盘页的倍数加载，因为mysql 也是按照页的方式存储数据
- 相比于B-树，B+ 树索引有序，并且叶子节点有链表相连，对于范围查找效率很高



## InnoDB 锁

### 共享锁和排它锁

InnoDB 实现了标准的行级锁，有两种类型的行级锁：

- shared lock ， s 锁，即共享锁。共享锁允许持有该锁的事务读取一行数据
- exclusive lock，x锁，即排它锁。排它锁允许持有该锁的事务更新或者删除一行数据

事务 **T1** 在 r 行记录 上持有一个共享锁，如果事务 **T2** 在 r 行记录上同时请求一个共享锁，那么该请求可以立即通过，**T1** 和 **T2** 同时持有一个 s 锁；如果事务**T2** 在r 行记录上同时请求一个排它锁，那么这个请求是不会被通过。

事务**T1** 在 r行记录上持有一个排它锁，另外一个事务 **T2** 无论是请求 s 锁还是 x 锁，都不会被通过。



### 意向锁

InnoDB 支持多粒度锁定，即允许行锁 和 表锁并存。例如可以使用 lock table 语句在指定表上添加 排它锁(x 锁)。为了使多粒度级别锁可行，InnoDB 使用意向锁。意向锁是表级锁，用来表明事务稍后需要哪种类型的锁(共享锁或者排它锁)。有两种类型的意向锁：

- 意向共享锁(IS)：表示事务打算在表的单个行上设置共享锁。
- 意向排它锁(IX)：表示事务打算在表的单个行上设置排它锁。

例如， select ... Lock in share mode 设置了一个 IS 锁，select ... for update 设置了一个 IX 锁。

意向锁遵循如下协议：

- 事务在获取表中某行上的共享锁之前，它必须先获取表上的 IS 锁或更强的锁。
- 事务在获取表中某行上的排它锁之前，必须先获取表上的 IX 锁。

下表汇总了表级锁类型兼容性：

|      | `X`      | `IX`       | `S`        | `IS`       |
| ---- | -------- | ---------- | ---------- | ---------- |
| `X`  | Conflict | Conflict   | Conflict   | Conflict   |
| `IX` | Conflict | Compatible | Conflict   | Compatible |
| `S`  | Conflict | Conflict   | Compatible | Compatible |
| `IS` | Conflict | Compatible | Compatible | Compatible |

如果请求事务与现有锁兼容，则会将锁授予该事务，如果它与现有锁冲突，则不会授予该事务。事务将一直等到冲突的现有锁被释放。如果锁请求与现有锁冲突，并且由于由于导致死锁而无法授权，则会发生错误。

意向锁不会阻塞除了全表请求(例如，lock tables ... write)的其他任何请求。意向锁的主要目的是显示某人正在锁定一行，或者将要锁定表中的一行。

### 记录锁（record lock）

记录锁是在一条索引记录上的一个锁。例如，select c1 from t where c1=10 for update；用于防止任何其他事务插入，更新，或者删除 c1 为 10 的值的记录。

记录锁永远锁索引记录，即使表中没有定义索引。在这种情况下，innodb 会创建一个隐藏的聚集索引，并使用这个索引来锁定记录。

### 间隙锁（gap lock）

间隙锁是指索引记录之间的间隙上的锁，或在第一个或最后一个索引记录之前或者之后的间隙上的锁。例如，select c1 from t where c1 between 10 and 20 for update.阻止其他事务插入 c1 值为 15的列

### next-key lock

## 索引

对于非常小的表，大部分情况下简单的全表扫描更高效；对于中到大型表，索引非常有效；对于特大型表，索引代价就会随之增加，此时可以使用诸如 分区技术。分表技术。

### 索引分类

#### 功能逻辑上

> 从功能逻辑上说，索引主要有 4 种，分别是`普通索引、唯一索引、主键索引和全文索引`。
>
> *唯一索引*就是在普通索引的基础上增加了数据唯一性的约束，在一张数据表里可以有多个唯一索引。
>
> *主键索引*在唯一索引的基础上增加了不为空的约束，也就是 NOT NULL+UNIQUE，一张表里最多只有一个主键索引

#### 物理实现方式

> `聚集索引和非聚集索引`。我们也把非聚集索引称为`二级索引或者辅助索引`。

### 索引的类型

#### B-Tree 索引

对如下的查询类型有效：

- 全值匹配
- 匹配最左前缀 （聚合索引）
- 匹配列前缀
- 匹配范围值
- 精确匹配某一列并范围匹配另外一列
- 只访问索引的查询

对如下查询限制索引

- 如果不是按照索引的最左列开始查找，则无法使用索引
- 不能跳过索引中的列
- 如果查询中有某个列的范围查询，则其右边所有列都无法使用索引优化查找

#### 全文索引

#### R-Tree

#### 其他

### 索引的优点

1. 索引大大减少了服务器需要扫描的数量
2. 索引可以帮助服务器避免排序和临时表
3. 索引可以将随机 I/O 变为顺序 I/O

### 高性能索引策略

1. 独立的列：索引列不能是表达式的一部分，也不能是函数的参数

2. 前缀索引和索引选择性

3. 多列索引

   > 5.0 之前多个单列索引必须使用 union all , 5.0之后引入了索引合并的策略

4. 选择合适的索引列顺序：去重后占比越大，越适合放在前面

5. 聚簇索引：不是一种单独的索引类型，而是一种数据存储方式



## 数据库事务

### 事务的四大特性

1. 原子性 atomicity：事务中包含的所有操作要么全部执行，要么全部不执行
2. 一致性 consistency：在事务操作前和事务处理后，其中的数据必须都满足业务规则约束
3. 隔离性 isolation：在事务提交之前，事务的影响对于其他事务是不可见的。
4. 持久性 durability：已提交的事务 所做出的改变是永久性的。

### 并发带来的问题

1. 脏读：事务读取了另一个事务写入但未提交的数据
2. 不可重复读：事务再次读取前一次读取的数据，发现另一个已提交的事务 修改 或者删除了要读取的数据
3. 幻读：事务再次执行查询语句，返回满足条件的一组数据，发现另一个已提交的事务插入了满足条件的数据。

### 隔离级别

1. 读未提交 ： 问题 1,2,3 可能会发生
2. 读已提交：问题2,3可能会发生，oracle 默认隔离级别
3. 可重复读：问题3可能会发生 ， mysql 默认隔离级别
4. 序列化：不会发生问题



## Spring 事务不生效

1. 入口的方法必须是public

2. Spring的事务管理默认只对出现运行期异常(java.lang.RuntimeException及其子类)进行回滚

3. 确认你的类是否被代理了

4. 确保你的业务和事务入口在同一个线程里，否则事务也是不生效的

5. service方法中调用本类中的另一个方法，事务没有生效

   > service 方法未加@Transactional 注解，另一个方法加了，不会生效， 注入自己bean 再调用才可以

## mysql 锁

```sql
-- 查看正在锁的事务
SELECT * FROM information_schema.innodb_trx;
-- 删除上锁的事务
kill [trx_mysql_thread_id]
```

