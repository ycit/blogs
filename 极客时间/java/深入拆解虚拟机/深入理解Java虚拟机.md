# 深入理解Java虚拟机

## 自动内存管理

### Java 内存区域与内存溢出异常

#### 运行时数据区域

- 线程共享数据区

  > 1. 方法区
  >
  >    > 存储已被虚拟机加载的**类型信息、常量、静态变量、即时编译器编译后的代码缓存**
  >    >
  >    > **运行时常量池**：方法区的一部分；class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池表，用于存储编译期生成的各种字面量与符号引用，这部分加载后存放到运行时常量池。
  >    >
  >    > 如果方法区无法满足新的内存分配需求时，将抛出 **OutofMemoryError**
  >
  > 2. Java 堆  head
  >
  >    > 存放对象实例
  >    >
  >    > 如果在 Java 堆中没有内存完成实例分配，并且堆也无法再扩展时，Java虚拟机将会抛出 **OutofMemoryError**
  >    >
  >    > 内存溢出处理方法：内存映像分析工具 （如 eclipse memory analyzer）对 Dump出来的堆转储快照进行分析。首先要确认是 内存溢出（memory overflow） 还是 内存泄露（memory leak），如果是内存泄露，需要通过 GC Root 的引用链，确定方法

- 线程隔离数据区

  > 1. 程序计数器
  >
  > 2. Java虚拟机栈  stack
  >
  >    > 每个方法被执行的时候，Java 虚拟机都会同步创建一个栈帧用于存储 **局部变量表**，**操作数栈**，**动态链接**，**方法出口**。每个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从**入栈到出栈**的过程
  >    >
  >    > 局部变量表：存放 编译期可知的 Java 虚拟机**基本数据类型**、**对象引用** 和  **returnAddress 类型**；其中 double、long 占 2 个 slot ，其余均占 1个 slot。局部变量表所需的内存空间在编译期间完成分配。
  >    >
  >    > 这个内存区域规定了两类异常状况：
  >    >
  >    > - 如果线程请求的栈深度大于虚拟机所允许的深度，将抛出 **StackOverflowError** 异常
  >    > - 如果 Java 虚拟机栈容量可以动态扩展，当栈扩展时无法申请到足够的内存会抛出 **OutofMemoryError**异常（Hotspot 虚拟机不支持动态扩展）
  >
  > 3. 本地方法栈
  >
  >    > 为虚拟机使用到的本地方法服务
  >    >
  >    > 也会抛出**StackOverflowError** 和 **OutofMemoryError**

#### 非运行时数据区域

1. 直接内存  Direct Memory

   > JDK 1.4 中的 NIO，引入了一种基于通道的 channel 与 缓冲区的 IO 方式，可以使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆里面的 DirectByteBuffer 对象作为这块内存的引用进行操作。

   

#### 对象探秘

1. 对象的创建

   > ①检查指令参数是否能在常量池中定位到一个类的符号引用
   >
   > ②并检查这个符号引用是否加载、解析、初始化
   >
   > ③为新生对象分配内存：
   >
   > - 指针碰撞（Bump the pointer）:要求 Java 堆中的内存是绝对规整的； 简单高效
   > - 空闲列表：维护一个列表，记录哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，不要求 内存是否规整；
   >
   > 使用哪种分配方式：根据垃圾收集器是是否带有空间压缩整理（compact）的能力决定
   >
   > 并发带来的内存分配问题：
   >
   > - 对分配内存空间的动作进行同步处理：实际上虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性
   > - 把内存分配的动过按照线程划分 在不同的空间之中进行，即每个线程在 Java 堆中先预分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer TLAB）
   >
   > ④将分配到的内存空间（不包括对象头）都初始化为零值
   >
   > ⑤对对象进行必要的设置
   >
   > - 对象是哪个类的实例
   > - 如何才能找到类的元数据信息
   > - 对象的哈希码
   > - 对象的 GC 分代年龄
   >
   > ⑥执行  <init> 方法，按照程序员的意愿对对象初始化
   >
   > 

2. 对象的内存布局

   > 对象在堆内存中存储布局：
   >
   > - 对象头 Header：两部分组成
   >   - Mark Word：存储对象自身的运行时数据，哈希码、GC分代年龄、锁状态标志位、线程持有的锁、偏向线程ID、偏向时间戳 ;  占用 32 比特 或者 64 比特
   >   - 类型指针：对象指向它的类型元数据的指针，通过该指针确定该对象是哪个类的实例；占用
   > - 实例数据 Instance data
   > - 对齐填充 Padding

3. 对象的访问定位

   > 栈上的 reference 操作 堆上的具体对象， reference类型 是一个 指向对象的引用 ； 这个引用有两种方式：
   >
   > - 句柄引用：句柄池， reference 中存储对象的句柄地址， 句柄中包含了对象实例数据（堆中） 与类型数据（栈中）各自的具体地址信息
   > - 直接指针：hotspot  使用此方式



### 垃圾收集器与内存分配策略

#### 对象已死

1. 判断对象已死的方法

   - 引用计数法：循环引用问题

   - 可达性分析：通过一系列称为 GC Root 的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程走过的路径称为 引用链，如果某个对象到 GC Roots 间没有任何引用链相连， 或者说 GC Roots 到这个对象不可达， 则证明 此对象是不可能再被使用的。

     > GC Roots 对象：
     >
     > 1. 虚拟机栈（栈帧中的本地变量表）中引用的对象，譬如参数、局部变量表、临时变量
     > 2. 方法区中类静态属性引用的对象，譬如 Java 类的引用类型静态变量
     > 3. 方法区中常量引用的对象，譬如 字符串常量池里的引用
     > 4. 本地方法栈中 JNI（Native 方法） 引用的对象
     > 5. 所有被同步锁持有的对象

2. 引用

   引用类型：

   - 强引用（Strongly Reference）：只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象

   - 软引用（Soft Reference）：有用但非必须的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。SoftReference

   - 弱引用（Weak Reference）：只能生存到下一次垃圾收集发生为止。WeakReference

     > 应用：ThreadLocal

   - 虚引用（Phantom Reference）：一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。

3. 在可达性分析算法中判定为不可达的对象，还未真正被宣布死亡， 一个对象真正被宣布死亡需要两次标记过程。

   > 如果对象在进行可达性分析后发现没有与 GC Root 相连接的 引用链，那么将会被第一次标记，随后进行一次筛选，筛选的条件是此对象是否有必要执行 finalize() 方法，如果有必要则被放入到F-Queue队列中。
   >
   > 稍后收集器会对 F-Queue 中的对象进行第二次小规模标记，如果对象在 finalize() 方法中成功拯救自己，那么在第二次标记时将被移出即将回收的集合。

#### 垃圾收集算法

分代收集理论

- 弱分代假说：绝大多数对象都是朝生夕死
- 强分代假说：熬过大多数垃圾收集过程的对象越难以消亡
- 跨代引用假说

部分收集（Partial GC）：不收集整个 Java 堆的垃圾收集

- 新生代收集（Minor GC/ Yong GC）
- 老年代收集（Major GC/ Old GC）：目前只有 CMS 收集器会有单独收集老年代的行为
- 混合收集（Mixed GC）：收集整个新生代 和 部分老年代的收集，目前只有 G1 收集器有这种行为
- 整堆收集（Full GC）：收集整个 Java 堆 和 方法区的垃圾收集

垃圾收集算法

- 标记-清除算法（sweep） ：执行效率不稳定 ； 内存空间碎片化问题
- 标记-复制算法，复制算法（copy）
- 标记-整理算法（compact）

垃圾收集器

新生代垃圾收集器

- Serial：可配合 CMS 使用
- ParNew：Serial 收集器的多线程版本，可配合 CMS 使用
- Parallel Scavenge：目标是达到一个可控制的吞吐量

老年代垃圾收集器

- Serial Old

- Parallel Old

- Concurrent Mark Sweep（CMS）：一种以获取最短回收停顿时间为目标的收集器

  > 收集过程
  >
  > - 初始标记 （initial mark） ：stop the world
  >
  > - 并发标记 （concurrent mark）
  >
  > - 重新标记 （remark）：stop the world
  >
  > - 并发清除 （concurrent sweep）
  >
  > 缺点
  >
  > - 对处理器资源非常敏感，因为占用了一部分线程
  > - 无法处理” 浮动垃圾“
  > - 使用 标记-清楚算法， 容易产生 碎片

- Garbage First  G1

  > 整体上看使用标记-整理算法，局部两个 Region 使用 标记-复制算法；基于 Region 的堆内存布局，即把连续的 Java 堆划分为多个大小相等的独立区域（Region），每个 Region 都可以根据需要，扮演新生代的 Eden 空间，Suvivor 空间 或者 老年代空间，收集器能对扮演不同角色的 Region 采取不同的策略去处理。Region 中的 Humongous 区域，专门用来存储大对象。
  >
  > 收集过程
  >
  > - 初始标记
  > - 并发标记
  > - 最终标记
  > - 筛选回收
  >
  > 优点
  >
  > - 可以指定最大停顿时间，分Region 的内存布局，按受益动态确定回收集