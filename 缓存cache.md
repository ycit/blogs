# 缓存

## 缓存问题

### 缓存穿透

- What

  查询缓存和数据库中都没有的数据

  查询数据库中一定不存在的数据，这样每次都会绕过缓存直接打到数据库

- How

  - 缓存空值，但是需要设置过期时间。

    > 
    >
    > 存在问题：内存中会存在大量不存在的key的数据

  - 布隆过滤器 BloomFilter

    > 比特向量，n 个 哈希函数算出的哈希值，结果置为1
    >
    > 当输入一个值时，算出n 个哈希值，看其向量是否为1，如果不是1，则一定不存在，如果是1，可能存在也可能不存在
    >
    > 算出不存在的值一定不存在，算出存在的值也可能不存在，牺牲正确率来换取空间。
    >
    > 在缓存之前加一层 BloomFilter，记录已有缓存的key，查询的时候先去 BloomFilter 查询，如果不存在就直接返回，存在再接着查询缓存，查询 db.

### 缓存击穿

- What

  查询缓存中没有的数据，数据库中有的数据（一般是缓存时间到期）。这时由于并发用户特别多，同时读取缓存读不到，又同时去数据库读，导致数据库压力瞬间增大。

- How

  - 热点数据永不过期
  - 添加互斥锁：第一个查询数据的请求使用互斥锁来锁住，其他线程拿不到锁就一直等待，直到第一个线程查询到数据，设置了缓存，那么后面的线层就会直接走缓存。

### 缓存雪崩

- What

  指缓存中数据大批量到过期时间，而查询数据量巨大，引起数据库压力过大甚至 down 机。和缓存击穿不同的是，缓存击穿指并发查同一条数据，缓存雪崩是指不同数据都过期了

- How

  - 缓存数据的过期时间设置随机
  - 设置多级缓存

## 热点问题

## redis

### 基本数据类型

> - String 
> - Hash：value 为 hashmap ,常用于 用户缓存，方便操作其中
> - List
> - Set
> - Sorted set

### 单线程为什么这么快

> - 纯内存操作
> - 单线程操作，避免频繁的上下文切换
> - 采用非阻塞 I/O 多路复用机制

### 过期策略以及内存淘汰机制